// Copyright 2026 the Execution Tape Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

// @generated by execution_tape_codegen. Do not edit by hand.

#[rustfmt::skip]
pub(crate) fn decode_instr(opcode: Opcode, r: &mut Reader<'_>) -> Result<Instr, DecodeError> {
    Ok(match opcode {
        Opcode::Nop => Instr::Nop,
        Opcode::Mov => {
            let dst = read_reg(r)?;
            let src = read_reg(r)?;
            Instr::Mov {
                dst,
                src,
            }
        },
        Opcode::Trap => {
            let code = read_u32_uleb(r)?;
            Instr::Trap {
                code,
            }
        },
        Opcode::ConstUnit => {
            let dst = read_reg(r)?;
            Instr::ConstUnit {
                dst,
            }
        },
        Opcode::ConstBool => {
            let dst = read_reg(r)?;
            let imm = r.read_u8()? != 0;
            Instr::ConstBool {
                dst,
                imm,
            }
        },
        Opcode::ConstI64 => {
            let dst = read_reg(r)?;
            let imm = r.read_sleb128_i64()?;
            Instr::ConstI64 {
                dst,
                imm,
            }
        },
        Opcode::ConstU64 => {
            let dst = read_reg(r)?;
            let imm = r.read_uleb128_u64()?;
            Instr::ConstU64 {
                dst,
                imm,
            }
        },
        Opcode::ConstF64 => {
            let dst = read_reg(r)?;
            let bits = r.read_u64_le()?;
            Instr::ConstF64 {
                dst,
                bits,
            }
        },
        Opcode::ConstDecimal => {
            let dst = read_reg(r)?;
            let mantissa = r.read_sleb128_i64()?;
            let scale = r.read_u8()?;
            Instr::ConstDecimal {
                dst,
                mantissa,
                scale,
            }
        },
        Opcode::ConstPool => {
            let dst = read_reg(r)?;
            let idx = ConstId(read_u32_uleb(r)?);
            Instr::ConstPool {
                dst,
                idx,
            }
        },
        Opcode::DecAdd => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::DecAdd {
                dst,
                a,
                b,
            }
        },
        Opcode::DecSub => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::DecSub {
                dst,
                a,
                b,
            }
        },
        Opcode::DecMul => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::DecMul {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Add => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Add {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Sub => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Sub {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Mul => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Mul {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Add => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Add {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Sub => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Sub {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Mul => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Mul {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Add => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Add {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Sub => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Sub {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Mul => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Mul {
                dst,
                a,
                b,
            }
        },
        Opcode::U64And => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64And {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Or => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Or {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Eq => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Eq {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Lt => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Lt {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Eq => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Eq {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Lt => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Lt {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Xor => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Xor {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Shl => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Shl {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Shr => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Shr {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Gt => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Gt {
                dst,
                a,
                b,
            }
        },
        Opcode::BoolNot => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::BoolNot {
                dst,
                a,
            }
        },
        Opcode::U64Le => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Le {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Ge => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Ge {
                dst,
                a,
                b,
            }
        },
        Opcode::I64And => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64And {
                dst,
                a,
                b,
            }
        },
        Opcode::U64ToI64 => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::U64ToI64 {
                dst,
                a,
            }
        },
        Opcode::I64ToU64 => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::I64ToU64 {
                dst,
                a,
            }
        },
        Opcode::I64Or => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Or {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Xor => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Xor {
                dst,
                a,
                b,
            }
        },
        Opcode::Select => {
            let dst = read_reg(r)?;
            let cond = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::Select {
                dst,
                cond,
                a,
                b,
            }
        },
        Opcode::I64Gt => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Gt {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Le => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Le {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Ge => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Ge {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Shl => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Shl {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Shr => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Shr {
                dst,
                a,
                b,
            }
        },
        Opcode::Br => {
            let cond = read_reg(r)?;
            let pc_true = read_u32_uleb(r)?;
            let pc_false = read_u32_uleb(r)?;
            Instr::Br {
                cond,
                pc_true,
                pc_false,
            }
        },
        Opcode::Jmp => {
            let pc_target = read_u32_uleb(r)?;
            Instr::Jmp {
                pc_target,
            }
        },
        Opcode::Call => {
            let eff_out = read_reg(r)?;
            let func_id = FuncId(read_u32_uleb(r)?);
            let eff_in = read_reg(r)?;
            let args_count = read_u32_uleb(r)?;
            let mut args = Vec::with_capacity(args_count as usize);
            for _ in 0..(args_count as usize) {
                args.push(read_reg(r)?);
            }
            let rets_count = read_u32_uleb(r)?;
            let mut rets = Vec::with_capacity(rets_count as usize);
            for _ in 0..(rets_count as usize) {
                rets.push(read_reg(r)?);
            }
            Instr::Call {
                eff_out,
                func_id,
                eff_in,
                args,
                rets,
            }
        },
        Opcode::Ret => {
            let eff_in = read_reg(r)?;
            let rets_count = read_u32_uleb(r)?;
            let mut rets = Vec::with_capacity(rets_count as usize);
            for _ in 0..(rets_count as usize) {
                rets.push(read_reg(r)?);
            }
            Instr::Ret {
                eff_in,
                rets,
            }
        },
        Opcode::HostCall => {
            let eff_out = read_reg(r)?;
            let host_sig = HostSigId(read_u32_uleb(r)?);
            let eff_in = read_reg(r)?;
            let args_count = read_u32_uleb(r)?;
            let mut args = Vec::with_capacity(args_count as usize);
            for _ in 0..(args_count as usize) {
                args.push(read_reg(r)?);
            }
            let rets_count = read_u32_uleb(r)?;
            let mut rets = Vec::with_capacity(rets_count as usize);
            for _ in 0..(rets_count as usize) {
                rets.push(read_reg(r)?);
            }
            Instr::HostCall {
                eff_out,
                host_sig,
                eff_in,
                args,
                rets,
            }
        },
        Opcode::TupleNew => {
            let dst = read_reg(r)?;
            let values_count = read_u32_uleb(r)?;
            let mut values = Vec::with_capacity(values_count as usize);
            for _ in 0..(values_count as usize) {
                values.push(read_reg(r)?);
            }
            Instr::TupleNew {
                dst,
                values,
            }
        },
        Opcode::TupleGet => {
            let dst = read_reg(r)?;
            let tuple = read_reg(r)?;
            let index = read_u32_uleb(r)?;
            Instr::TupleGet {
                dst,
                tuple,
                index,
            }
        },
        Opcode::StructNew => {
            let dst = read_reg(r)?;
            let type_id = TypeId(read_u32_uleb(r)?);
            let values_count = read_u32_uleb(r)?;
            let mut values = Vec::with_capacity(values_count as usize);
            for _ in 0..(values_count as usize) {
                values.push(read_reg(r)?);
            }
            Instr::StructNew {
                dst,
                type_id,
                values,
            }
        },
        Opcode::StructGet => {
            let dst = read_reg(r)?;
            let st = read_reg(r)?;
            let field_index = read_u32_uleb(r)?;
            Instr::StructGet {
                dst,
                st,
                field_index,
            }
        },
        Opcode::ArrayNew => {
            let dst = read_reg(r)?;
            let elem_type_id = ElemTypeId(read_u32_uleb(r)?);
            let values_count = read_u32_uleb(r)?;
            let mut values = Vec::with_capacity(values_count as usize);
            for _ in 0..(values_count as usize) {
                values.push(read_reg(r)?);
            }
            let len = values_count;
            Instr::ArrayNew {
                dst,
                elem_type_id,
                len,
                values,
            }
        },
        Opcode::ArrayLen => {
            let dst = read_reg(r)?;
            let arr = read_reg(r)?;
            Instr::ArrayLen {
                dst,
                arr,
            }
        },
        Opcode::ArrayGet => {
            let dst = read_reg(r)?;
            let arr = read_reg(r)?;
            let index = read_reg(r)?;
            Instr::ArrayGet {
                dst,
                arr,
                index,
            }
        },
        Opcode::TupleLen => {
            let dst = read_reg(r)?;
            let tuple = read_reg(r)?;
            Instr::TupleLen {
                dst,
                tuple,
            }
        },
        Opcode::StructFieldCount => {
            let dst = read_reg(r)?;
            let st = read_reg(r)?;
            Instr::StructFieldCount {
                dst,
                st,
            }
        },
        Opcode::ArrayGetImm => {
            let dst = read_reg(r)?;
            let arr = read_reg(r)?;
            let index = read_u32_uleb(r)?;
            Instr::ArrayGetImm {
                dst,
                arr,
                index,
            }
        },
        Opcode::BytesLen => {
            let dst = read_reg(r)?;
            let bytes = read_reg(r)?;
            Instr::BytesLen {
                dst,
                bytes,
            }
        },
        Opcode::StrLen => {
            let dst = read_reg(r)?;
            let s = read_reg(r)?;
            Instr::StrLen {
                dst,
                s,
            }
        },
        Opcode::I64Div => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Div {
                dst,
                a,
                b,
            }
        },
        Opcode::I64Rem => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::I64Rem {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Div => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Div {
                dst,
                a,
                b,
            }
        },
        Opcode::U64Rem => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::U64Rem {
                dst,
                a,
                b,
            }
        },
        Opcode::I64ToF64 => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::I64ToF64 {
                dst,
                a,
            }
        },
        Opcode::U64ToF64 => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::U64ToF64 {
                dst,
                a,
            }
        },
        Opcode::F64ToI64 => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::F64ToI64 {
                dst,
                a,
            }
        },
        Opcode::F64ToU64 => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::F64ToU64 {
                dst,
                a,
            }
        },
        Opcode::DecToI64 => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::DecToI64 {
                dst,
                a,
            }
        },
        Opcode::DecToU64 => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::DecToU64 {
                dst,
                a,
            }
        },
        Opcode::I64ToDec => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let scale = r.read_u8()?;
            Instr::I64ToDec {
                dst,
                a,
                scale,
            }
        },
        Opcode::U64ToDec => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let scale = r.read_u8()?;
            Instr::U64ToDec {
                dst,
                a,
                scale,
            }
        },
        Opcode::BytesEq => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::BytesEq {
                dst,
                a,
                b,
            }
        },
        Opcode::StrEq => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::StrEq {
                dst,
                a,
                b,
            }
        },
        Opcode::BytesConcat => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::BytesConcat {
                dst,
                a,
                b,
            }
        },
        Opcode::StrConcat => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::StrConcat {
                dst,
                a,
                b,
            }
        },
        Opcode::BytesGet => {
            let dst = read_reg(r)?;
            let bytes = read_reg(r)?;
            let index = read_reg(r)?;
            Instr::BytesGet {
                dst,
                bytes,
                index,
            }
        },
        Opcode::BytesGetImm => {
            let dst = read_reg(r)?;
            let bytes = read_reg(r)?;
            let index = read_u32_uleb(r)?;
            Instr::BytesGetImm {
                dst,
                bytes,
                index,
            }
        },
        Opcode::BytesSlice => {
            let dst = read_reg(r)?;
            let bytes = read_reg(r)?;
            let start = read_reg(r)?;
            let end = read_reg(r)?;
            Instr::BytesSlice {
                dst,
                bytes,
                start,
                end,
            }
        },
        Opcode::StrSlice => {
            let dst = read_reg(r)?;
            let s = read_reg(r)?;
            let start = read_reg(r)?;
            let end = read_reg(r)?;
            Instr::StrSlice {
                dst,
                s,
                start,
                end,
            }
        },
        Opcode::StrToBytes => {
            let dst = read_reg(r)?;
            let s = read_reg(r)?;
            Instr::StrToBytes {
                dst,
                s,
            }
        },
        Opcode::BytesToStr => {
            let dst = read_reg(r)?;
            let bytes = read_reg(r)?;
            Instr::BytesToStr {
                dst,
                bytes,
            }
        },
        Opcode::F64Div => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Div {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Eq => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Eq {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Lt => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Lt {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Gt => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Gt {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Le => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Le {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Ge => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Ge {
                dst,
                a,
                b,
            }
        },
        Opcode::BoolAnd => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::BoolAnd {
                dst,
                a,
                b,
            }
        },
        Opcode::BoolOr => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::BoolOr {
                dst,
                a,
                b,
            }
        },
        Opcode::BoolXor => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::BoolXor {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Neg => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::F64Neg {
                dst,
                a,
            }
        },
        Opcode::F64Abs => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::F64Abs {
                dst,
                a,
            }
        },
        Opcode::F64Min => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Min {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Max => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Max {
                dst,
                a,
                b,
            }
        },
        Opcode::F64MinNum => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64MinNum {
                dst,
                a,
                b,
            }
        },
        Opcode::F64MaxNum => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64MaxNum {
                dst,
                a,
                b,
            }
        },
        Opcode::F64Rem => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            let b = read_reg(r)?;
            Instr::F64Rem {
                dst,
                a,
                b,
            }
        },
        Opcode::F64ToBits => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::F64ToBits {
                dst,
                a,
            }
        },
        Opcode::F64FromBits => {
            let dst = read_reg(r)?;
            let a = read_reg(r)?;
            Instr::F64FromBits {
                dst,
                a,
            }
        },
    })
}
