---
id: et-d900
status: open
deps: []
links: []
created: 2026-02-04T07:08:03Z
type: task
priority: 1
assignee: Bruce Mitchener
tags: [exec, opcode, codegen, ir, verifier, bytecode]
---
# ExecInstr + JSON opcode spec (checked-in generated code)

## Design

Add a next-stage “AOT-ish” representation for verified execution (`ExecInstr`) and a single
source-of-truth opcode specification in JSON, with checked-in generated Rust to keep the VM,
bytecode encode/decode, and verifier operand rules in sync.

### Goals

- Eliminate repeated “we just know” opcode facts scattered across modules (decoder, verifier,
  disasm, reads/writes, terminator classification).
- Provide a natural stepping stone toward an AOT-ish verified interpreter:
  `VerifiedProgram` → `ExecutableProgram` (per-function `Vec<ExecInstr>` with resolved targets).
- Keep the core crate `no_std + alloc` friendly: generated code is plain Rust; codegen tooling is
  a separate std-only crate.

### Non-goals (v1)

- No native-code JIT.
- No new on-disk bytecode format version solely for this refactor.
- No “full verifier” rewrite; only move the **mechanical** per-op operand rules next to opcode
  definitions.

### Structure

- `execution_tape/opcodes.json`: opcode specs:
  - opcode byte value
  - mnemonic/name
  - operand schema (regs/immediates/ranges)
  - `is_terminator`
  - read/write register sets (in terms of operand names)
  - basic operand-verifier rules (reg bounds, reg class, arity)
  - per-op “custom verifier hook” name for complex invariants (optional)
- `execution_tape/src/opcodes_gen.rs`: generated, checked in.
- `execution_tape_codegen/` (new workspace crate, std-only):
  - reads `opcodes.json`
  - generates `opcodes_gen.rs`
  - emits stable formatting (deterministic output)
  - CI check to ensure `opcodes_gen.rs` matches `opcodes.json`

### ExecInstr

Introduce an internal IR used for verified execution:
- `pub(crate) enum ExecInstr` with one struct/variant per opcode.
- Operands use typed reg indices (`I64Reg`, `BoolReg`, etc.) after verifier lowering.
- Branch targets are resolved to instruction indices (`ip`) rather than byte PCs.
- Optional per-instruction span id table for fast tracing/trap reporting.

This is purely internal initially; the public API remains `VerifiedProgram` + `Vm::run(...)`.

### Rollout plan (keep the repo green)

1) Add `opcodes.json` and the codegen crate; generate `opcodes_gen.rs` with *only* `Opcode` +
   stable opcode byte mapping + `is_terminator`. Switch existing code to use it.
2) Generate `reads()`/`writes()` mappings and move disasm/verifier to rely on them.
3) Generate decode/encode plumbing behind a temporary internal gate; add parity tests against
   the existing decoder.
4) Add `ExecInstr` + compile step from `VerifiedProgram` to `ExecutableProgram` behind an internal
   API; keep `Vm::run` unchanged initially.
5) Switch verified execution path to interpret `ExecInstr` (AOT-ish), benchmark, and remove old
   paths when stable.

## Acceptance

- `opcodes.json` exists and is the single source of truth for opcode bytes and basic metadata.
- Generated `execution_tape/src/opcodes_gen.rs` is checked in and used by `Opcode` classification
  (at minimum: `from_u8`, `to_u8`, `is_terminator`).
- A std-only codegen crate exists and can regenerate the file deterministically.
- CI/repo hygiene: a documented command to regen + a check that fails if generated code is stale.
- `ExecInstr` exists (internal) and a conversion from verified bytecode to `ExecInstr` resolves
  jump targets to instruction indices.
- `cargo fmt`, `cargo clippy -- -D warnings`, and `cargo test --workspace --all-features` pass.
