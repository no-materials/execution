// Copyright 2026 the Execution Tape Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

#![doc = "Code generator for `execution_tape` opcode tables.\n\n\
          This is a std-only build tool crate. It is not shipped as part of the core VM.\n"]

use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result, bail};
use serde::Deserialize;

#[derive(Deserialize)]
struct Spec {
    version: u32,
    opcodes: Vec<OpcodeSpec>,
}

#[derive(Deserialize)]
struct OpcodeSpec {
    name: String,
    mnemonic: String,
    byte: String,
    terminator: bool,
    flags: Vec<String>,
    doc: Option<String>,
    operands: Vec<OperandSpec>,
}

#[derive(Deserialize)]
struct OperandSpec {
    kind: String,
    role: String,
    encoding: String,
}

fn parse_u8_hex(s: &str) -> Result<u8> {
    let s = s.trim();
    let raw = s
        .strip_prefix("0x")
        .or_else(|| s.strip_prefix("0X"))
        .unwrap_or(s);
    u8::from_str_radix(raw, 16).with_context(|| format!("invalid opcode byte '{s}'"))
}

fn fmt_hex_u8(b: u8) -> String {
    format!("0x{b:02X}")
}

fn max_opcode_byte(ops: &[(u8, OpcodeSpec)]) -> u8 {
    ops.iter().map(|(b, _)| *b).max().unwrap_or_default()
}

fn operand_kind_rust(operand: &str) -> Result<&'static str> {
    Ok(match operand {
        "reg" => "OperandKind::Reg",
        "reg_list" => "OperandKind::RegList",
        "pc" => "OperandKind::Pc",

        "imm_bool" => "OperandKind::ImmBool",
        "imm_u8" => "OperandKind::ImmU8",
        "imm_u32" => "OperandKind::ImmU32",
        "imm_i64" => "OperandKind::ImmI64",
        "imm_u64" => "OperandKind::ImmU64",

        "const_id" => "OperandKind::ConstId",
        "func_id" => "OperandKind::FuncId",
        "host_sig_id" => "OperandKind::HostSigId",
        "type_id" => "OperandKind::TypeId",
        "elem_type_id" => "OperandKind::ElemTypeId",

        other => bail!("unknown operand kind '{other}'"),
    })
}

fn operand_role_rust(role: &str) -> Result<String> {
    let mut s = String::with_capacity("OperandRole::".len() + role.len());
    s.push_str("OperandRole::");
    let mut upper_next = true;
    for ch in role.chars() {
        if ch == '_' {
            upper_next = true;
            continue;
        }
        if upper_next {
            s.extend(ch.to_uppercase());
            upper_next = false;
        } else {
            s.push(ch);
        }
    }
    Ok(s)
}

fn operand_encoding_rust(enc: &str) -> Result<&'static str> {
    Ok(match enc {
        "reg_u32_uleb" => "OperandEncoding::RegU32Uleb",
        "reg_list_u32_uleb_count_then_regs" => "OperandEncoding::RegListU32UlebCountThenRegs",

        "bool_u8" => "OperandEncoding::BoolU8",
        "u8_raw" => "OperandEncoding::U8Raw",
        "u32_uleb" => "OperandEncoding::U32Uleb",
        "i64_sleb" => "OperandEncoding::I64Sleb",
        "u64_uleb" => "OperandEncoding::U64Uleb",
        "u64_le" => "OperandEncoding::U64Le",

        other => bail!("unknown operand encoding '{other}'"),
    })
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
struct Layout {
    start: u16,
    len: u8,
}

fn generate(spec: Spec, src: &Path) -> Result<String> {
    if spec.version != 1 {
        bail!("unsupported opcodes.json version {}", spec.version);
    }

    let mut ops: Vec<(u8, OpcodeSpec)> = Vec::with_capacity(spec.opcodes.len());
    for op in spec.opcodes {
        let b = parse_u8_hex(&op.byte)?;
        ops.push((b, op));
    }

    ops.sort_by(|(b0, o0), (b1, o1)| b0.cmp(b1).then_with(|| o0.name.cmp(&o1.name)));

    for w in ops.windows(2) {
        let (b0, o0) = &w[0];
        let (b1, o1) = &w[1];
        if b0 == b1 {
            bail!(
                "duplicate opcode byte {}: {} and {}",
                fmt_hex_u8(*b0),
                o0.name,
                o1.name
            );
        }
        if o0.name == o1.name {
            bail!("duplicate opcode name '{}'", o0.name);
        }
    }

    let mut out = String::new();
    out.push_str("// Copyright 2026 the Execution Tape Authors\n");
    out.push_str("// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n");
    out.push_str("// @generated by execution_tape_codegen. Do not edit by hand.\n");
    let _ = src;
    out.push('\n');

    out.push_str("/// Operand kinds used by the opcode table.\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("pub enum OperandKind {\n");
    out.push_str("    /// A single virtual register.\n");
    out.push_str("    Reg,\n");
    out.push_str("    /// A list of virtual registers.\n");
    out.push_str("    RegList,\n");
    out.push_str("    /// A bytecode PC (byte offset).\n");
    out.push_str("    Pc,\n");
    out.push_str("    /// An immediate `bool`.\n");
    out.push_str("    ImmBool,\n");
    out.push_str("    /// An immediate `u8`.\n");
    out.push_str("    ImmU8,\n");
    out.push_str("    /// An immediate `u32`.\n");
    out.push_str("    ImmU32,\n");
    out.push_str("    /// An immediate `i64`.\n");
    out.push_str("    ImmI64,\n");
    out.push_str("    /// An immediate `u64`.\n");
    out.push_str("    ImmU64,\n");
    out.push_str("    /// A constant pool index.\n");
    out.push_str("    ConstId,\n");
    out.push_str("    /// A function index.\n");
    out.push_str("    FuncId,\n");
    out.push_str("    /// A host signature index.\n");
    out.push_str("    HostSigId,\n");
    out.push_str("    /// A struct type index.\n");
    out.push_str("    TypeId,\n");
    out.push_str("    /// An array element type index.\n");
    out.push_str("    ElemTypeId,\n");
    out.push_str("}\n\n");

    out.push_str("/// Operand roles used by the opcode table.\n");
    out.push_str("///\n");
    out.push_str("/// Roles are a best-effort description for disassembly/tooling.\n");
    out.push_str("#[allow(missing_docs, reason = \"generated\")]\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("pub enum OperandRole {\n");
    out.push_str("    Dst,\n");
    out.push_str("    Src,\n");
    out.push_str("    A,\n");
    out.push_str("    B,\n");
    out.push_str("    Cond,\n");
    out.push_str("    PcTrue,\n");
    out.push_str("    PcFalse,\n");
    out.push_str("    PcTarget,\n");
    out.push_str("    Imm,\n");
    out.push_str("    Bits,\n");
    out.push_str("    Mantissa,\n");
    out.push_str("    Scale,\n");
    out.push_str("    TrapCode,\n");
    out.push_str("    Const,\n");
    out.push_str("    Func,\n");
    out.push_str("    HostSig,\n");
    out.push_str("    Type,\n");
    out.push_str("    ElemType,\n");
    out.push_str("    EffIn,\n");
    out.push_str("    EffOut,\n");
    out.push_str("    Args,\n");
    out.push_str("    Rets,\n");
    out.push_str("    Values,\n");
    out.push_str("    Tuple,\n");
    out.push_str("    St,\n");
    out.push_str("    Arr,\n");
    out.push_str("    Index,\n");
    out.push_str("    FieldIndex,\n");
    out.push_str("    Start,\n");
    out.push_str("    End,\n");
    out.push_str("    Bytes,\n");
    out.push_str("    S,\n");
    out.push_str("}\n\n");

    out.push_str("/// Operand encodings used by the bytecode codec.\n");
    out.push_str("#[allow(missing_docs, reason = \"generated\")]\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("pub enum OperandEncoding {\n");
    out.push_str("    RegU32Uleb,\n");
    out.push_str("    RegListU32UlebCountThenRegs,\n");
    out.push_str("    BoolU8,\n");
    out.push_str("    U8Raw,\n");
    out.push_str("    U32Uleb,\n");
    out.push_str("    I64Sleb,\n");
    out.push_str("    U64Uleb,\n");
    out.push_str("    U64Le,\n");
    out.push_str("}\n\n");

    out.push_str("/// Operand schema metadata (kind/role/encoding).\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("pub struct OperandSchema {\n");
    out.push_str("    /// Operand kind (semantic type).\n");
    out.push_str("    pub kind: OperandKind,\n");
    out.push_str("    /// Operand role (how this operand is used).\n");
    out.push_str("    pub role: OperandRole,\n");
    out.push_str("    /// Operand encoding used by the bytecode codec.\n");
    out.push_str("    pub encoding: OperandEncoding,\n");
    out.push_str("}\n\n");

    out.push_str("impl OperandSchema {\n");
    out.push_str("    const fn new(kind: OperandKind, role: OperandRole, encoding: OperandEncoding) -> Self {\n");
    out.push_str("        Self { kind, role, encoding }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    out.push_str("/// Operand layout for an opcode (indices into `OPERANDS`).\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("pub struct OperandLayout {\n");
    out.push_str("    /// Start index in `OPERANDS`.\n");
    out.push_str("    pub start: u16,\n");
    out.push_str("    /// Number of operand entries.\n");
    out.push_str("    pub len: u8,\n");
    out.push_str("}\n\n");

    let mut operands: Vec<String> = Vec::new();
    let mut operand_layout_by_name: Vec<(&str, u16, u8)> = Vec::with_capacity(ops.len());
    for (_, op) in &ops {
        let start: u16 = operands
            .len()
            .try_into()
            .context("too many operands to index in u16")?;
        for operand in &op.operands {
            let kind = operand_kind_rust(&operand.kind)?;
            let role = operand_role_rust(&operand.role)?;
            let encoding = operand_encoding_rust(&operand.encoding)?;
            operands.push(format!("OperandSchema::new({kind}, {role}, {encoding})"));
        }
        let len: u8 = op
            .operands
            .len()
            .try_into()
            .with_context(|| format!("too many operands for opcode {}", op.name))?;
        operand_layout_by_name.push((op.name.as_str(), start, len));
    }

    let max_byte = max_opcode_byte(&ops);
    let mut layout_by_byte: Vec<Option<Layout>> = vec![None; usize::from(max_byte) + 1];
    for ((b, op), (name, start, len)) in ops.iter().zip(operand_layout_by_name.iter()) {
        let _ = (op, name);
        layout_by_byte[usize::from(*b)] = Some(Layout {
            start: *start,
            len: *len,
        });
    }

    out.push_str("/// Flat operand schema table indexed by `OperandLayout`.\n");
    out.push_str("pub const OPERANDS: &[OperandSchema] = &[\n");
    for operand in &operands {
        out.push_str(&format!("    {operand},\n"));
    }
    out.push_str("];\n\n");

    out.push_str("/// Per-opcode metadata used by decode, disasm, and verification.\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("pub struct OpcodeInfo {\n");
    out.push_str("    /// Stable, parseable opcode name.\n");
    out.push_str("    pub mnemonic: &'static str,\n");
    out.push_str("    /// Whether this opcode terminates the current basic block.\n");
    out.push_str("    pub is_terminator: bool,\n");
    out.push_str("    /// Optional per-opcode traits.\n");
    out.push_str("    pub flags: OpcodeFlags,\n");
    out.push_str("    /// Operand layout for this opcode.\n");
    out.push_str("    pub operands: OperandLayout,\n");
    out.push_str("}\n\n");

    out.push_str("/// Optional per-opcode traits.\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("#[repr(transparent)]\n");
    out.push_str("pub struct OpcodeFlags(u8);\n\n");

    out.push_str("impl OpcodeFlags {\n");
    out.push_str("    /// No flags set.\n");
    out.push_str("    pub const NONE: Self = Self(0);\n");
    out.push_str("    /// Call-like instruction (`call`, `host_call`, `ret`).\n");
    out.push_str("    pub const CALL_LIKE: Self = Self(1 << 0);\n");
    out.push_str("\n    /// Returns `true` if `other` is a subset of `self`.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub const fn contains(self, other: Self) -> bool {\n");
    out.push_str("        (self.0 & other.0) == other.0\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    let mut by_byte: Vec<Option<&OpcodeSpec>> = vec![None; usize::from(max_byte) + 1];
    for (b, op) in &ops {
        by_byte[usize::from(*b)] = Some(op);
    }

    out.push_str("/// Metadata indexed by opcode byte.\n");
    out.push_str("pub const OPCODE_INFO_BY_BYTE: &[OpcodeInfo] = &[\n");
    for (i, op) in by_byte.iter().enumerate() {
        if let Some(op) = op {
            let layout = layout_by_byte[i].expect("layout for valid opcode");
            let flags = if op.flags.iter().any(|f| f == "call_like") {
                "OpcodeFlags::CALL_LIKE"
            } else {
                "OpcodeFlags::NONE"
            };
            out.push_str(&format!(
                "    OpcodeInfo {{ mnemonic: \"{}\", is_terminator: {}, flags: {}, operands: OperandLayout {{ start: {}, len: {} }} }}, // 0x{:<02X} {}\n",
                op.mnemonic, op.terminator, flags, layout.start, layout.len, i, op.name
            ));
        } else {
            out.push_str(&format!(
                "    OpcodeInfo {{ mnemonic: \"<invalid>\", is_terminator: false, flags: OpcodeFlags::NONE, operands: OperandLayout {{ start: 0, len: 0 }} }}, // 0x{:<02X}\n",
                i
            ));
        }
    }
    out.push_str("];\n\n");

    out.push_str("/// Bytecode opcode byte for the v1 instruction set.\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("#[repr(u8)]\n");
    out.push_str("pub enum Opcode {\n");
    for (b, op) in &ops {
        let doc = op
            .doc
            .as_deref()
            .with_context(|| format!("missing doc for opcode {}", op.name))?;
        for line in doc.lines() {
            out.push_str(&format!("    /// {line}\n"));
        }
        out.push_str(&format!("    {} = {},\n", op.name, fmt_hex_u8(*b)));
    }
    out.push_str("}\n\n");

    out.push_str("impl Opcode {\n");
    out.push_str("    /// Decodes an opcode byte.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn from_u8(b: u8) -> Option<Self> {\n");
    out.push_str("        Some(match b {\n");
    for (b, op) in &ops {
        out.push_str(&format!(
            "            {} => Self::{},\n",
            fmt_hex_u8(*b),
            op.name
        ));
    }
    out.push_str("            _ => return None,\n");
    out.push_str("        })\n");
    out.push_str("    }\n\n");

    out.push_str("    /// Returns `true` if this opcode terminates the current basic block.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn is_terminator(self) -> bool {\n");
    out.push_str("        self.info().is_terminator\n");
    out.push_str("    }\n");

    out.push_str("\n    /// Stable, parseable opcode name.\n");
    out.push_str("    ///\n");
    out.push_str("    /// This string is used by the disassembler output.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn mnemonic(self) -> &'static str {\n");
    out.push_str("        self.info().mnemonic\n");
    out.push_str("    }\n");

    out.push_str("\n    /// Returns opcode metadata for this opcode.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn info(self) -> &'static OpcodeInfo {\n");
    out.push_str("        &OPCODE_INFO_BY_BYTE[usize::from(self as u8)]\n");
    out.push_str("    }\n");

    out.push_str("\n    /// Returns `true` if this opcode is call-like.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn is_call_like(self) -> bool {\n");
    out.push_str("        self.info().flags.contains(OpcodeFlags::CALL_LIKE)\n");
    out.push_str("    }\n");

    out.push_str("\n    /// Returns operand schema descriptors for this opcode.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn operands(self) -> &'static [OperandSchema] {\n");
    out.push_str("        let layout = self.info().operands;\n");
    out.push_str("        let start = usize::from(layout.start);\n");
    out.push_str("        let end = start + usize::from(layout.len);\n");
    out.push_str("        &OPERANDS[start..end]\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    Ok(out)
}

fn main() -> Result<()> {
    let mut args = std::env::args().skip(1);
    let spec_path: PathBuf = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("execution_tape/opcodes.json"));
    let out_path: PathBuf = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("execution_tape/src/opcodes_gen.rs"));
    if args.next().is_some() {
        bail!("usage: execution_tape_codegen [spec.json] [out.rs]");
    }

    let json =
        fs::read_to_string(&spec_path).with_context(|| format!("read {}", spec_path.display()))?;
    let spec: Spec =
        serde_json::from_str(&json).with_context(|| format!("parse {}", spec_path.display()))?;

    let rendered = generate(spec, &spec_path)?;

    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent).with_context(|| format!("create {}", parent.display()))?;
    }
    fs::write(&out_path, rendered.as_bytes())
        .with_context(|| format!("write {}", out_path.display()))?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::{Spec, generate};
    use std::fs;
    use std::path::PathBuf;

    fn normalize_newlines(s: &str) -> String {
        // On Windows, git autocrlf can check in generated `.rs` files with `\r\n` line endings.
        // Normalize so the drift test validates content, not platform line terminators.
        s.replace("\r\n", "\n").replace('\r', "\n")
    }

    #[test]
    fn generated_file_is_up_to_date() {
        let workspace_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let workspace_root = workspace_root.parent().expect("workspace root");

        let spec_path = workspace_root.join("execution_tape/opcodes.json");
        let out_path = workspace_root.join("execution_tape/src/opcodes_gen.rs");

        let json = fs::read_to_string(&spec_path).expect("read opcodes.json");
        let spec: Spec = serde_json::from_str(&json).expect("parse opcodes.json");

        let rendered = generate(spec, &spec_path).expect("render opcodes_gen.rs");
        let existing = fs::read_to_string(&out_path).expect("read opcodes_gen.rs");

        assert_eq!(
            normalize_newlines(&rendered),
            normalize_newlines(&existing),
            "generated file is out of date; re-run: \
             cargo run -p execution_tape_codegen -- execution_tape/opcodes.json execution_tape/src/opcodes_gen.rs"
        );
    }
}
