// Copyright 2026 the Execution Tape Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

#![doc = "Code generator for `execution_tape` opcode tables.\n\n\
          This is a std-only build tool crate. It is not shipped as part of the core VM.\n"]

use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result, bail};
use serde::Deserialize;

#[derive(Deserialize)]
struct Spec {
    version: u32,
    opcodes: Vec<OpcodeSpec>,
}

#[derive(Deserialize)]
struct OpcodeSpec {
    name: String,
    byte: String,
    terminator: bool,
}

fn parse_u8_hex(s: &str) -> Result<u8> {
    let s = s.trim();
    let raw = s
        .strip_prefix("0x")
        .or_else(|| s.strip_prefix("0X"))
        .unwrap_or(s);
    u8::from_str_radix(raw, 16).with_context(|| format!("invalid opcode byte '{s}'"))
}

fn fmt_hex_u8(b: u8) -> String {
    format!("0x{b:02X}")
}

fn generate(spec: Spec, src: &Path) -> Result<String> {
    if spec.version != 1 {
        bail!("unsupported opcodes.json version {}", spec.version);
    }

    let mut ops: Vec<(u8, OpcodeSpec)> = Vec::with_capacity(spec.opcodes.len());
    for op in spec.opcodes {
        let b = parse_u8_hex(&op.byte)?;
        ops.push((b, op));
    }

    ops.sort_by(|(b0, o0), (b1, o1)| b0.cmp(b1).then_with(|| o0.name.cmp(&o1.name)));

    for w in ops.windows(2) {
        let (b0, o0) = &w[0];
        let (b1, o1) = &w[1];
        if b0 == b1 {
            bail!(
                "duplicate opcode byte {}: {} and {}",
                fmt_hex_u8(*b0),
                o0.name,
                o1.name
            );
        }
        if o0.name == o1.name {
            bail!("duplicate opcode name '{}'", o0.name);
        }
    }

    let mut out = String::new();
    out.push_str("// Copyright 2026 the Execution Tape Authors\n");
    out.push_str("// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n");
    out.push_str("// @generated by execution_tape_codegen. Do not edit by hand.\n");
    out.push_str(&format!("// Source: {}\n\n", src.display()));

    out.push_str("/// Bytecode opcode byte for the v1 instruction set.\n");
    out.push_str("#[allow(missing_docs, reason = \"generated\")]\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("#[repr(u8)]\n");
    out.push_str("pub enum Opcode {\n");
    for (b, op) in &ops {
        out.push_str(&format!("    {} = {},\n", op.name, fmt_hex_u8(*b)));
    }
    out.push_str("}\n\n");

    out.push_str("impl Opcode {\n");
    out.push_str("    /// Decodes an opcode byte.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn from_u8(b: u8) -> Option<Self> {\n");
    out.push_str("        Some(match b {\n");
    for (b, op) in &ops {
        out.push_str(&format!(
            "            {} => Self::{},\n",
            fmt_hex_u8(*b),
            op.name
        ));
    }
    out.push_str("            _ => return None,\n");
    out.push_str("        })\n");
    out.push_str("    }\n\n");

    out.push_str("    /// Returns `true` if this opcode terminates the current basic block.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn is_terminator(self) -> bool {\n");
    out.push_str("        matches!(self, ");

    let terms: Vec<&str> = ops
        .iter()
        .filter_map(|(_, o)| o.terminator.then_some(o.name.as_str()))
        .collect();

    if terms.is_empty() {
        out.push_str(")\n");
    } else {
        for (i, t) in terms.iter().enumerate() {
            if i == 0 {
                out.push_str("Self::");
            } else {
                out.push_str(" | Self::");
            }
            out.push_str(t);
        }
        out.push_str(")\n");
    }

    out.push_str("    }\n");
    out.push_str("}\n");

    Ok(out)
}

fn main() -> Result<()> {
    let mut args = std::env::args().skip(1);
    let spec_path: PathBuf = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("execution_tape/opcodes.json"));
    let out_path: PathBuf = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("execution_tape/src/opcodes_gen.rs"));
    if args.next().is_some() {
        bail!("usage: execution_tape_codegen [spec.json] [out.rs]");
    }

    let json =
        fs::read_to_string(&spec_path).with_context(|| format!("read {}", spec_path.display()))?;
    let spec: Spec =
        serde_json::from_str(&json).with_context(|| format!("parse {}", spec_path.display()))?;

    let rendered = generate(spec, &spec_path)?;

    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent).with_context(|| format!("create {}", parent.display()))?;
    }
    fs::write(&out_path, rendered.as_bytes())
        .with_context(|| format!("write {}", out_path.display()))?;
    Ok(())
}
