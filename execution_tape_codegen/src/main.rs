// Copyright 2026 the Execution Tape Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

#![doc = "Code generator for `execution_tape` opcode tables.\n\n\
          This is a std-only build tool crate. It is not shipped as part of the core VM.\n"]

use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result, bail};
use serde::Deserialize;

#[derive(Deserialize)]
struct Spec {
    version: u32,
    opcodes: Vec<OpcodeSpec>,
}

#[derive(Deserialize)]
struct OpcodeSpec {
    name: String,
    mnemonic: String,
    byte: String,
    terminator: bool,
    doc: Option<String>,
}

fn parse_u8_hex(s: &str) -> Result<u8> {
    let s = s.trim();
    let raw = s
        .strip_prefix("0x")
        .or_else(|| s.strip_prefix("0X"))
        .unwrap_or(s);
    u8::from_str_radix(raw, 16).with_context(|| format!("invalid opcode byte '{s}'"))
}

fn fmt_hex_u8(b: u8) -> String {
    format!("0x{b:02X}")
}

fn max_opcode_byte(ops: &[(u8, OpcodeSpec)]) -> u8 {
    ops.iter().map(|(b, _)| *b).max().unwrap_or_default()
}

fn generate(spec: Spec, src: &Path) -> Result<String> {
    if spec.version != 1 {
        bail!("unsupported opcodes.json version {}", spec.version);
    }

    let mut ops: Vec<(u8, OpcodeSpec)> = Vec::with_capacity(spec.opcodes.len());
    for op in spec.opcodes {
        let b = parse_u8_hex(&op.byte)?;
        ops.push((b, op));
    }

    ops.sort_by(|(b0, o0), (b1, o1)| b0.cmp(b1).then_with(|| o0.name.cmp(&o1.name)));

    for w in ops.windows(2) {
        let (b0, o0) = &w[0];
        let (b1, o1) = &w[1];
        if b0 == b1 {
            bail!(
                "duplicate opcode byte {}: {} and {}",
                fmt_hex_u8(*b0),
                o0.name,
                o1.name
            );
        }
        if o0.name == o1.name {
            bail!("duplicate opcode name '{}'", o0.name);
        }
    }

    let mut out = String::new();
    out.push_str("// Copyright 2026 the Execution Tape Authors\n");
    out.push_str("// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n");
    out.push_str("// @generated by execution_tape_codegen. Do not edit by hand.\n");
    let _ = src;
    out.push('\n');

    out.push_str("/// Per-opcode metadata used by decode, disasm, and verification.\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("pub struct OpcodeInfo {\n");
    out.push_str("    /// Stable, parseable opcode name.\n");
    out.push_str("    pub mnemonic: &'static str,\n");
    out.push_str("    /// Whether this opcode terminates the current basic block.\n");
    out.push_str("    pub is_terminator: bool,\n");
    out.push_str("}\n\n");

    let max_byte = max_opcode_byte(&ops);
    let mut by_byte: Vec<Option<&OpcodeSpec>> = vec![None; usize::from(max_byte) + 1];
    for (b, op) in &ops {
        by_byte[usize::from(*b)] = Some(op);
    }

    out.push_str("/// Metadata indexed by opcode byte.\n");
    out.push_str("pub const OPCODE_INFO_BY_BYTE: &[OpcodeInfo] = &[\n");
    for (i, op) in by_byte.iter().enumerate() {
        if let Some(op) = op {
            out.push_str(&format!(
                "    OpcodeInfo {{ mnemonic: \"{}\", is_terminator: {} }}, // 0x{:<02X} {}\n",
                op.mnemonic, op.terminator, i, op.name
            ));
        } else {
            out.push_str(&format!(
                "    OpcodeInfo {{ mnemonic: \"<invalid>\", is_terminator: false }}, // 0x{:<02X}\n",
                i
            ));
        }
    }
    out.push_str("];\n\n");

    out.push_str("/// Bytecode opcode byte for the v1 instruction set.\n");
    out.push_str("#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n");
    out.push_str("#[repr(u8)]\n");
    out.push_str("pub enum Opcode {\n");
    for (b, op) in &ops {
        let doc = op
            .doc
            .as_deref()
            .with_context(|| format!("missing doc for opcode {}", op.name))?;
        for line in doc.lines() {
            out.push_str(&format!("    /// {line}\n"));
        }
        out.push_str(&format!("    {} = {},\n", op.name, fmt_hex_u8(*b)));
    }
    out.push_str("}\n\n");

    out.push_str("impl Opcode {\n");
    out.push_str("    /// Decodes an opcode byte.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn from_u8(b: u8) -> Option<Self> {\n");
    out.push_str("        Some(match b {\n");
    for (b, op) in &ops {
        out.push_str(&format!(
            "            {} => Self::{},\n",
            fmt_hex_u8(*b),
            op.name
        ));
    }
    out.push_str("            _ => return None,\n");
    out.push_str("        })\n");
    out.push_str("    }\n\n");

    out.push_str("    /// Returns `true` if this opcode terminates the current basic block.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn is_terminator(self) -> bool {\n");
    out.push_str("        self.info().is_terminator\n");
    out.push_str("    }\n");

    out.push_str("\n    /// Stable, parseable opcode name.\n");
    out.push_str("    ///\n");
    out.push_str("    /// This string is used by the disassembler output.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn mnemonic(self) -> &'static str {\n");
    out.push_str("        self.info().mnemonic\n");
    out.push_str("    }\n");

    out.push_str("\n    /// Returns opcode metadata for this opcode.\n");
    out.push_str("    #[must_use]\n");
    out.push_str("    pub fn info(self) -> &'static OpcodeInfo {\n");
    out.push_str("        &OPCODE_INFO_BY_BYTE[usize::from(self as u8)]\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    Ok(out)
}

fn main() -> Result<()> {
    let mut args = std::env::args().skip(1);
    let spec_path: PathBuf = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("execution_tape/opcodes.json"));
    let out_path: PathBuf = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("execution_tape/src/opcodes_gen.rs"));
    if args.next().is_some() {
        bail!("usage: execution_tape_codegen [spec.json] [out.rs]");
    }

    let json =
        fs::read_to_string(&spec_path).with_context(|| format!("read {}", spec_path.display()))?;
    let spec: Spec =
        serde_json::from_str(&json).with_context(|| format!("parse {}", spec_path.display()))?;

    let rendered = generate(spec, &spec_path)?;

    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent).with_context(|| format!("create {}", parent.display()))?;
    }
    fs::write(&out_path, rendered.as_bytes())
        .with_context(|| format!("write {}", out_path.display()))?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::{Spec, generate};
    use std::fs;
    use std::path::PathBuf;

    fn normalize_newlines(s: &str) -> String {
        // On Windows, git autocrlf can check in generated `.rs` files with `\r\n` line endings.
        // Normalize so the drift test validates content, not platform line terminators.
        s.replace("\r\n", "\n").replace('\r', "\n")
    }

    #[test]
    fn generated_file_is_up_to_date() {
        let workspace_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let workspace_root = workspace_root.parent().expect("workspace root");

        let spec_path = workspace_root.join("execution_tape/opcodes.json");
        let out_path = workspace_root.join("execution_tape/src/opcodes_gen.rs");

        let json = fs::read_to_string(&spec_path).expect("read opcodes.json");
        let spec: Spec = serde_json::from_str(&json).expect("parse opcodes.json");

        let rendered = generate(spec, &spec_path).expect("render opcodes_gen.rs");
        let existing = fs::read_to_string(&out_path).expect("read opcodes_gen.rs");

        assert_eq!(
            normalize_newlines(&rendered),
            normalize_newlines(&existing),
            "generated file is out of date; re-run: \
             cargo run -p execution_tape_codegen -- execution_tape/opcodes.json execution_tape/src/opcodes_gen.rs"
        );
    }
}
